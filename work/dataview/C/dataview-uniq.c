/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview-uniq.h"



flag asn1SccMyInteger_Equal(const asn1SccMyInteger* pVal1, const asn1SccMyInteger* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccMyInteger_Initialize(asn1SccMyInteger* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccMyInteger_IsConstraintValid(const asn1SccMyInteger* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 10000UL);
    *pErrCode = ret ? 0 :  ERR_MYINTEGER; 

	return ret;
}

flag asn1SccMyInteger_Encode(const asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccMyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 10000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMyInteger_Decode(asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 10000);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYINTEGER;

	return ret  && asn1SccMyInteger_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMyInteger_ACN_Encode(const asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccMyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 10000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMyInteger_ACN_Decode(asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 10000);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYINTEGER;

    return ret && asn1SccMyInteger_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccUInt8_Equal(const asn1SccUInt8* pVal1, const asn1SccUInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccUInt8_Initialize(asn1SccUInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccUInt8_IsConstraintValid(const asn1SccUInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_UINT8; 

	return ret;
}

flag asn1SccUInt8_Encode(const asn1SccUInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccUInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccUInt8_Decode(asn1SccUInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT8;

	return ret  && asn1SccUInt8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccUInt8_ACN_Encode(const asn1SccUInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccUInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccUInt8_ACN_Decode(asn1SccUInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT8;

    return ret && asn1SccUInt8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPacket_Equal(const asn1SccPacket* pVal1, const asn1SccPacket* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 100; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void asn1SccPacket_Initialize(asn1SccPacket* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 100) {
	    asn1SccUInt8_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccPacket_IsConstraintValid(const asn1SccPacket* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 100; i1++) 
    {
    	ret = asn1SccUInt8_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccPacket_Encode(const asn1SccPacket* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? asn1SccPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)100) && ret; i1++) 
	    {
	    	ret = asn1SccUInt8_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPacket_Decode(asn1SccPacket* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)100) && ret; i1++) 
	{
		ret = asn1SccUInt8_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccPacket_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPacket_ACN_Encode(const asn1SccPacket* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? asn1SccPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)100) && ret; i1++) 
	    {
	    	ret = asn1SccUInt8_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPacket_ACN_Decode(asn1SccPacket* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)100) && ret; i1++) 
	{
		ret = asn1SccUInt8_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && asn1SccPacket_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccUInt16_Equal(const asn1SccUInt16* pVal1, const asn1SccUInt16* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccUInt16_Initialize(asn1SccUInt16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccUInt16_IsConstraintValid(const asn1SccUInt16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_UINT16; 

	return ret;
}

flag asn1SccUInt16_Encode(const asn1SccUInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccUInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccUInt16_Decode(asn1SccUInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT16;

	return ret  && asn1SccUInt16_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccUInt16_ACN_Encode(const asn1SccUInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccUInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccUInt16_ACN_Decode(asn1SccUInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT16;

    return ret && asn1SccUInt16_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccMessage_packetType_Equal(const asn1SccMessage_packetType* pVal1, const asn1SccMessage_packetType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccMessage_data_Equal(const asn1SccMessage_data* pVal1, const asn1SccMessage_data* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 1024; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag asn1SccMessage_Equal(const asn1SccMessage* pVal1, const asn1SccMessage* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccMessage_packetType_Equal((&(pVal1->packetType)), (&(pVal2->packetType)));

    if (ret) {
        ret = (pVal1->serviceType == pVal2->serviceType);

        if (ret) {
            ret = (pVal1->messageType == pVal2->messageType);

            if (ret) {
                ret = (pVal1->applicationId == pVal2->applicationId);

                if (ret) {
                    ret = (pVal1->messageTypeCounter == pVal2->messageTypeCounter);

                    if (ret) {
                        ret = (pVal1->packetSequenceCount == pVal2->packetSequenceCount);

                        if (ret) {
                            ret = (pVal1->dataSize == pVal2->dataSize);

                            if (ret) {
                                ret = asn1SccMessage_data_Equal((&(pVal1->data)), (&(pVal2->data)));

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void asn1SccMessage_packetType_Initialize(asn1SccMessage_packetType* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1Scctm;
}
void asn1SccMessage_data_Initialize(asn1SccMessage_data* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 1024) {
	    asn1SccUInt16_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void asn1SccMessage_Initialize(asn1SccMessage* pVal)
{
	(void)pVal;



	/*set packetType */
	asn1SccMessage_packetType_Initialize((&(pVal->packetType)));
	/*set serviceType */
	asn1SccUInt8_Initialize((&(pVal->serviceType)));
	/*set messageType */
	asn1SccUInt8_Initialize((&(pVal->messageType)));
	/*set applicationId */
	asn1SccUInt16_Initialize((&(pVal->applicationId)));
	/*set messageTypeCounter */
	asn1SccUInt16_Initialize((&(pVal->messageTypeCounter)));
	/*set packetSequenceCount */
	asn1SccUInt16_Initialize((&(pVal->packetSequenceCount)));
	/*set dataSize */
	asn1SccUInt16_Initialize((&(pVal->dataSize)));
	/*set data */
	asn1SccMessage_data_Initialize((&(pVal->data)));
}

flag asn1SccMessage_IsConstraintValid(const asn1SccMessage* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = (((pVal->packetType == asn1Scctm)) || ((pVal->packetType == asn1Scctc)));
    *pErrCode = ret ? 0 :  ERR_MESSAGE_PACKETTYPE; 
    if (ret) {
        ret = asn1SccUInt8_IsConstraintValid((&(pVal->serviceType)), pErrCode);
        if (ret) {
            ret = asn1SccUInt8_IsConstraintValid((&(pVal->messageType)), pErrCode);
            if (ret) {
                ret = asn1SccUInt16_IsConstraintValid((&(pVal->applicationId)), pErrCode);
                if (ret) {
                    ret = asn1SccUInt16_IsConstraintValid((&(pVal->messageTypeCounter)), pErrCode);
                    if (ret) {
                        ret = asn1SccUInt16_IsConstraintValid((&(pVal->packetSequenceCount)), pErrCode);
                        if (ret) {
                            ret = asn1SccUInt16_IsConstraintValid((&(pVal->dataSize)), pErrCode);
                            if (ret) {
                                for(i1 = 0; ret && i1 < 1024; i1++) 
                                {
                                	ret = asn1SccUInt16_IsConstraintValid((&(pVal->data.arr[i1])), pErrCode);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccMessage_Encode(const asn1SccMessage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? asn1SccMessage_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode packetType */
	    switch(pVal->packetType) 
	    {
	        case asn1Scctm:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case asn1Scctc:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_MESSAGE_PACKETTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	        /*Encode serviceType */
	        ret = asn1SccUInt8_Encode((&(pVal->serviceType)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode messageType */
	            ret = asn1SccUInt8_Encode((&(pVal->messageType)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode applicationId */
	                ret = asn1SccUInt16_Encode((&(pVal->applicationId)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode messageTypeCounter */
	                    ret = asn1SccUInt16_Encode((&(pVal->messageTypeCounter)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode packetSequenceCount */
	                        ret = asn1SccUInt16_Encode((&(pVal->packetSequenceCount)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode dataSize */
	                            ret = asn1SccUInt16_Encode((&(pVal->dataSize)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode data */
	                                	
	                                for(i1=0; (i1 < (int)1024) && ret; i1++) 
	                                {
	                                	ret = asn1SccUInt16_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMessage_Decode(asn1SccMessage* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode packetType */
	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_MESSAGE_PACKETTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                pVal->packetType = asn1Scctm;
	                break;
	            case 1: 
	                pVal->packetType = asn1Scctc;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_MESSAGE_PACKETTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        pVal->packetType = asn1Scctm;             /*COVERAGE_IGNORE*/
	    }
	}
	if (ret) {
	    /*Decode serviceType */
	    ret = asn1SccUInt8_Decode((&(pVal->serviceType)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode messageType */
	        ret = asn1SccUInt8_Decode((&(pVal->messageType)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode applicationId */
	            ret = asn1SccUInt16_Decode((&(pVal->applicationId)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode messageTypeCounter */
	                ret = asn1SccUInt16_Decode((&(pVal->messageTypeCounter)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode packetSequenceCount */
	                    ret = asn1SccUInt16_Decode((&(pVal->packetSequenceCount)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode dataSize */
	                        ret = asn1SccUInt16_Decode((&(pVal->dataSize)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode data */
	                            	
	                            for(i1=0; (i1 < (int)1024) && ret; i1++) 
	                            {
	                            	ret = asn1SccUInt16_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccMessage_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMessage_ACN_Encode(const asn1SccMessage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	int i1;
	ret = bCheckConstraints ? asn1SccMessage_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode packetType */
	    switch(pVal->packetType) { 
	        case asn1Scctm:
	            uIntVal = 0;
	            break;
	        case asn1Scctc:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_MESSAGE_PACKETTYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
	    if (ret) {
	        /*Encode serviceType */
	        ret = asn1SccUInt8_ACN_Encode((&(pVal->serviceType)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode messageType */
	            ret = asn1SccUInt8_ACN_Encode((&(pVal->messageType)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode applicationId */
	                ret = asn1SccUInt16_ACN_Encode((&(pVal->applicationId)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode messageTypeCounter */
	                    ret = asn1SccUInt16_ACN_Encode((&(pVal->messageTypeCounter)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode packetSequenceCount */
	                        ret = asn1SccUInt16_ACN_Encode((&(pVal->packetSequenceCount)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode dataSize */
	                            ret = asn1SccUInt16_ACN_Encode((&(pVal->dataSize)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode data */
	                                	
	                                for(i1=0; (i1 < (int)1024) && ret; i1++) 
	                                {
	                                	ret = asn1SccUInt16_ACN_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                }
	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMessage_ACN_Decode(asn1SccMessage* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;
	int i1;

	/*Decode packetType */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MESSAGE_PACKETTYPE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            pVal->packetType = asn1Scctm;
	            break;
	        case 1:
	            pVal->packetType = asn1Scctc;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_MESSAGE_PACKETTYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/
	if (ret) {
	    /*Decode serviceType */
	    ret = asn1SccUInt8_ACN_Decode((&(pVal->serviceType)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode messageType */
	        ret = asn1SccUInt8_ACN_Decode((&(pVal->messageType)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode applicationId */
	            ret = asn1SccUInt16_ACN_Decode((&(pVal->applicationId)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode messageTypeCounter */
	                ret = asn1SccUInt16_ACN_Decode((&(pVal->messageTypeCounter)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode packetSequenceCount */
	                    ret = asn1SccUInt16_ACN_Decode((&(pVal->packetSequenceCount)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode dataSize */
	                        ret = asn1SccUInt16_ACN_Decode((&(pVal->dataSize)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode data */
	                            	
	                            for(i1=0; (i1 < (int)1024) && ret; i1++) 
	                            {
	                            	ret = asn1SccUInt16_ACN_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	                            }
	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && asn1SccMessage_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccEventOccured_Equal(const asn1SccEventOccured* pVal1, const asn1SccEventOccured* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccEventOccured_Initialize(asn1SccEventOccured* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1SccinformativeUnknownEvent;
}

flag asn1SccEventOccured_IsConstraintValid(const asn1SccEventOccured* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((*(pVal)) == asn1SccinformativeUnknownEvent)) || (((*(pVal)) == asn1SccwwdgReset)))) || (((*(pVal)) == asn1SccassertionFail)))) || (((*(pVal)) == asn1SccmCUStart)))) || (((*(pVal)) == asn1ScclowSeverityUnknownEvent)))) || (((*(pVal)) == asn1SccmediumSeverityUnknownEvent)))) || (((*(pVal)) == asn1ScchighSeverityUnknownEvent)))) || (((*(pVal)) == asn1SccfailedStartOfExecution)));
    *pErrCode = ret ? 0 :  ERR_EVENTOCCURED; 

	return ret;
}

flag asn1SccEventOccured_Encode(const asn1SccEventOccured* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccEventOccured_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1SccinformativeUnknownEvent:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 7);
	        	break;
	        case asn1SccwwdgReset:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 7);
	        	break;
	        case asn1SccassertionFail:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 7);
	        	break;
	        case asn1SccmCUStart:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 7);
	        	break;
	        case asn1ScclowSeverityUnknownEvent:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 7);
	        	break;
	        case asn1SccmediumSeverityUnknownEvent:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 7);
	        	break;
	        case asn1ScchighSeverityUnknownEvent:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 7);
	        	break;
	        case asn1SccfailedStartOfExecution:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 7);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_EVENTOCCURED; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccEventOccured_Decode(asn1SccEventOccured* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 7);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_EVENTOCCURED;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1SccinformativeUnknownEvent;
	                break;
	            case 1: 
	                (*(pVal)) = asn1SccwwdgReset;
	                break;
	            case 2: 
	                (*(pVal)) = asn1SccassertionFail;
	                break;
	            case 3: 
	                (*(pVal)) = asn1SccmCUStart;
	                break;
	            case 4: 
	                (*(pVal)) = asn1ScclowSeverityUnknownEvent;
	                break;
	            case 5: 
	                (*(pVal)) = asn1SccmediumSeverityUnknownEvent;
	                break;
	            case 6: 
	                (*(pVal)) = asn1ScchighSeverityUnknownEvent;
	                break;
	            case 7: 
	                (*(pVal)) = asn1SccfailedStartOfExecution;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_EVENTOCCURED;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1SccinformativeUnknownEvent;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccEventOccured_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccEventOccured_ACN_Encode(const asn1SccEventOccured* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccEventOccured_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1SccinformativeUnknownEvent:
	            uIntVal = 0;
	            break;
	        case asn1SccwwdgReset:
	            uIntVal = 1;
	            break;
	        case asn1SccassertionFail:
	            uIntVal = 2;
	            break;
	        case asn1SccmCUStart:
	            uIntVal = 3;
	            break;
	        case asn1ScclowSeverityUnknownEvent:
	            uIntVal = 4;
	            break;
	        case asn1SccmediumSeverityUnknownEvent:
	            uIntVal = 5;
	            break;
	        case asn1ScchighSeverityUnknownEvent:
	            uIntVal = 6;
	            break;
	        case asn1SccfailedStartOfExecution:
	            uIntVal = 7;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_EVENTOCCURED;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 7);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccEventOccured_ACN_Decode(asn1SccEventOccured* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 7);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_EVENTOCCURED;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1SccinformativeUnknownEvent;
	            break;
	        case 1:
	            (*(pVal)) = asn1SccwwdgReset;
	            break;
	        case 2:
	            (*(pVal)) = asn1SccassertionFail;
	            break;
	        case 3:
	            (*(pVal)) = asn1SccmCUStart;
	            break;
	        case 4:
	            (*(pVal)) = asn1ScclowSeverityUnknownEvent;
	            break;
	        case 5:
	            (*(pVal)) = asn1SccmediumSeverityUnknownEvent;
	            break;
	        case 6:
	            (*(pVal)) = asn1ScchighSeverityUnknownEvent;
	            break;
	        case 7:
	            (*(pVal)) = asn1SccfailedStartOfExecution;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_EVENTOCCURED;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccEventOccured_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAcceptanceErrorOccured_Equal(const asn1SccAcceptanceErrorOccured* pVal1, const asn1SccAcceptanceErrorOccured* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccAcceptanceErrorOccured_Initialize(asn1SccAcceptanceErrorOccured* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1SccunknownAcceptanceError;
}

flag asn1SccAcceptanceErrorOccured_IsConstraintValid(const asn1SccAcceptanceErrorOccured* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((*(pVal)) == asn1SccunknownAcceptanceError)) || (((*(pVal)) == asn1SccmessageTooShort)))) || (((*(pVal)) == asn1ScctooManyBitsRead)))) || (((*(pVal)) == asn1SccstringTooShort)))) || (((*(pVal)) == asn1SccunacceptableMessage)));
    *pErrCode = ret ? 0 :  ERR_ACCEPTANCEERROROCCURED; 

	return ret;
}

flag asn1SccAcceptanceErrorOccured_Encode(const asn1SccAcceptanceErrorOccured* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccAcceptanceErrorOccured_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1SccunknownAcceptanceError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
	        	break;
	        case asn1SccmessageTooShort:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
	        	break;
	        case asn1ScctooManyBitsRead:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
	        	break;
	        case asn1SccstringTooShort:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
	        	break;
	        case asn1SccunacceptableMessage:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_ACCEPTANCEERROROCCURED; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAcceptanceErrorOccured_Decode(asn1SccAcceptanceErrorOccured* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_ACCEPTANCEERROROCCURED;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1SccunknownAcceptanceError;
	                break;
	            case 1: 
	                (*(pVal)) = asn1SccmessageTooShort;
	                break;
	            case 2: 
	                (*(pVal)) = asn1ScctooManyBitsRead;
	                break;
	            case 3: 
	                (*(pVal)) = asn1SccstringTooShort;
	                break;
	            case 4: 
	                (*(pVal)) = asn1SccunacceptableMessage;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_ACCEPTANCEERROROCCURED;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1SccunknownAcceptanceError;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccAcceptanceErrorOccured_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAcceptanceErrorOccured_ACN_Encode(const asn1SccAcceptanceErrorOccured* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccAcceptanceErrorOccured_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1SccunknownAcceptanceError:
	            uIntVal = 0;
	            break;
	        case asn1SccmessageTooShort:
	            uIntVal = 1;
	            break;
	        case asn1ScctooManyBitsRead:
	            uIntVal = 2;
	            break;
	        case asn1SccstringTooShort:
	            uIntVal = 3;
	            break;
	        case asn1SccunacceptableMessage:
	            uIntVal = 4;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_ACCEPTANCEERROROCCURED;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 4);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAcceptanceErrorOccured_ACN_Decode(asn1SccAcceptanceErrorOccured* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ACCEPTANCEERROROCCURED;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1SccunknownAcceptanceError;
	            break;
	        case 1:
	            (*(pVal)) = asn1SccmessageTooShort;
	            break;
	        case 2:
	            (*(pVal)) = asn1ScctooManyBitsRead;
	            break;
	        case 3:
	            (*(pVal)) = asn1SccstringTooShort;
	            break;
	        case 4:
	            (*(pVal)) = asn1SccunacceptableMessage;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_ACCEPTANCEERROROCCURED;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccAcceptanceErrorOccured_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccRoutingErrorType_Equal(const asn1SccRoutingErrorType* pVal1, const asn1SccRoutingErrorType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccRoutingErrorType_Initialize(asn1SccRoutingErrorType* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1SccunknownRoutingError;
}

flag asn1SccRoutingErrorType_IsConstraintValid(const asn1SccRoutingErrorType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) == asn1SccunknownRoutingError);
    *pErrCode = ret ? 0 :  ERR_ROUTINGERRORTYPE; 

	return ret;
}

flag asn1SccRoutingErrorType_Encode(const asn1SccRoutingErrorType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccRoutingErrorType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1SccunknownRoutingError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_ROUTINGERRORTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccRoutingErrorType_Decode(asn1SccRoutingErrorType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 0);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_ROUTINGERRORTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1SccunknownRoutingError;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_ROUTINGERRORTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1SccunknownRoutingError;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccRoutingErrorType_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccRoutingErrorType_ACN_Encode(const asn1SccRoutingErrorType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccRoutingErrorType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1SccunknownRoutingError:
	            uIntVal = 0;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_ROUTINGERRORTYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 0);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccRoutingErrorType_ACN_Decode(asn1SccRoutingErrorType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 0);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ROUTINGERRORTYPE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1SccunknownRoutingError;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_ROUTINGERRORTYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccRoutingErrorType_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccExecutionStartErrorType_Equal(const asn1SccExecutionStartErrorType* pVal1, const asn1SccExecutionStartErrorType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccExecutionStartErrorType_Initialize(asn1SccExecutionStartErrorType* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1SccunknownExecutionStartError;
}

flag asn1SccExecutionStartErrorType_IsConstraintValid(const asn1SccExecutionStartErrorType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((*(pVal)) == asn1SccunknownExecutionStartError)) || (((*(pVal)) == asn1ScceventActionDefinitionIDExistsError)))) || (((*(pVal)) == asn1ScceventActionDeleteEnabledDefinitionError)))) || (((*(pVal)) == asn1ScceventActionUnknownEventDefinitionError)))) || (((*(pVal)) == asn1ScceventActionUnknownEventActionDefinitionIDError)))) || (((*(pVal)) == asn1SccsubServiceExecutionStartError)))) || (((*(pVal)) == asn1SccinstructionExecutionStartError)))) || (((*(pVal)) == asn1SccsetNonExistingParameter)))) || (((*(pVal)) == asn1SccgetNonExistingParameter)));
    *pErrCode = ret ? 0 :  ERR_EXECUTIONSTARTERRORTYPE; 

	return ret;
}

flag asn1SccExecutionStartErrorType_Encode(const asn1SccExecutionStartErrorType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccExecutionStartErrorType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1SccunknownExecutionStartError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 8);
	        	break;
	        case asn1ScceventActionDefinitionIDExistsError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 8);
	        	break;
	        case asn1ScceventActionDeleteEnabledDefinitionError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 8);
	        	break;
	        case asn1ScceventActionUnknownEventDefinitionError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 8);
	        	break;
	        case asn1ScceventActionUnknownEventActionDefinitionIDError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 8);
	        	break;
	        case asn1SccsubServiceExecutionStartError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 8);
	        	break;
	        case asn1SccinstructionExecutionStartError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 8);
	        	break;
	        case asn1SccsetNonExistingParameter:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 8);
	        	break;
	        case asn1SccgetNonExistingParameter:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 8);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_EXECUTIONSTARTERRORTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccExecutionStartErrorType_Decode(asn1SccExecutionStartErrorType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 8);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_EXECUTIONSTARTERRORTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1SccunknownExecutionStartError;
	                break;
	            case 1: 
	                (*(pVal)) = asn1ScceventActionDefinitionIDExistsError;
	                break;
	            case 2: 
	                (*(pVal)) = asn1ScceventActionDeleteEnabledDefinitionError;
	                break;
	            case 3: 
	                (*(pVal)) = asn1ScceventActionUnknownEventDefinitionError;
	                break;
	            case 4: 
	                (*(pVal)) = asn1ScceventActionUnknownEventActionDefinitionIDError;
	                break;
	            case 5: 
	                (*(pVal)) = asn1SccsubServiceExecutionStartError;
	                break;
	            case 6: 
	                (*(pVal)) = asn1SccinstructionExecutionStartError;
	                break;
	            case 7: 
	                (*(pVal)) = asn1SccsetNonExistingParameter;
	                break;
	            case 8: 
	                (*(pVal)) = asn1SccgetNonExistingParameter;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_EXECUTIONSTARTERRORTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1SccunknownExecutionStartError;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccExecutionStartErrorType_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccExecutionStartErrorType_ACN_Encode(const asn1SccExecutionStartErrorType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccExecutionStartErrorType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1SccunknownExecutionStartError:
	            uIntVal = 0;
	            break;
	        case asn1ScceventActionDefinitionIDExistsError:
	            uIntVal = 1;
	            break;
	        case asn1ScceventActionDeleteEnabledDefinitionError:
	            uIntVal = 2;
	            break;
	        case asn1ScceventActionUnknownEventDefinitionError:
	            uIntVal = 3;
	            break;
	        case asn1ScceventActionUnknownEventActionDefinitionIDError:
	            uIntVal = 4;
	            break;
	        case asn1SccsubServiceExecutionStartError:
	            uIntVal = 5;
	            break;
	        case asn1SccinstructionExecutionStartError:
	            uIntVal = 6;
	            break;
	        case asn1SccsetNonExistingParameter:
	            uIntVal = 7;
	            break;
	        case asn1SccgetNonExistingParameter:
	            uIntVal = 8;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_EXECUTIONSTARTERRORTYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 8);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccExecutionStartErrorType_ACN_Decode(asn1SccExecutionStartErrorType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 8);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_EXECUTIONSTARTERRORTYPE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1SccunknownExecutionStartError;
	            break;
	        case 1:
	            (*(pVal)) = asn1ScceventActionDefinitionIDExistsError;
	            break;
	        case 2:
	            (*(pVal)) = asn1ScceventActionDeleteEnabledDefinitionError;
	            break;
	        case 3:
	            (*(pVal)) = asn1ScceventActionUnknownEventDefinitionError;
	            break;
	        case 4:
	            (*(pVal)) = asn1ScceventActionUnknownEventActionDefinitionIDError;
	            break;
	        case 5:
	            (*(pVal)) = asn1SccsubServiceExecutionStartError;
	            break;
	        case 6:
	            (*(pVal)) = asn1SccinstructionExecutionStartError;
	            break;
	        case 7:
	            (*(pVal)) = asn1SccsetNonExistingParameter;
	            break;
	        case 8:
	            (*(pVal)) = asn1SccgetNonExistingParameter;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_EXECUTIONSTARTERRORTYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccExecutionStartErrorType_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccExecutionProgressErrorType_Equal(const asn1SccExecutionProgressErrorType* pVal1, const asn1SccExecutionProgressErrorType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccExecutionProgressErrorType_Initialize(asn1SccExecutionProgressErrorType* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1SccunknownExecutionProgressError;
}

flag asn1SccExecutionProgressErrorType_IsConstraintValid(const asn1SccExecutionProgressErrorType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) == asn1SccunknownExecutionProgressError);
    *pErrCode = ret ? 0 :  ERR_EXECUTIONPROGRESSERRORTYPE; 

	return ret;
}

flag asn1SccExecutionProgressErrorType_Encode(const asn1SccExecutionProgressErrorType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccExecutionProgressErrorType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1SccunknownExecutionProgressError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_EXECUTIONPROGRESSERRORTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccExecutionProgressErrorType_Decode(asn1SccExecutionProgressErrorType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 0);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_EXECUTIONPROGRESSERRORTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1SccunknownExecutionProgressError;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_EXECUTIONPROGRESSERRORTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1SccunknownExecutionProgressError;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccExecutionProgressErrorType_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccExecutionProgressErrorType_ACN_Encode(const asn1SccExecutionProgressErrorType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccExecutionProgressErrorType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1SccunknownExecutionProgressError:
	            uIntVal = 0;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_EXECUTIONPROGRESSERRORTYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 0);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccExecutionProgressErrorType_ACN_Decode(asn1SccExecutionProgressErrorType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 0);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_EXECUTIONPROGRESSERRORTYPE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1SccunknownExecutionProgressError;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_EXECUTIONPROGRESSERRORTYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccExecutionProgressErrorType_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccExecutionCompletionErrorType_Equal(const asn1SccExecutionCompletionErrorType* pVal1, const asn1SccExecutionCompletionErrorType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccExecutionCompletionErrorType_Initialize(asn1SccExecutionCompletionErrorType* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1SccunknownExecutionCompletionError;
}

flag asn1SccExecutionCompletionErrorType_IsConstraintValid(const asn1SccExecutionCompletionErrorType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == asn1SccunknownExecutionCompletionError)) || (((*(pVal)) == asn1SccchecksumFailed)))) || (((*(pVal)) == asn1SccaddressOutOfRange)));
    *pErrCode = ret ? 0 :  ERR_EXECUTIONCOMPLETIONERRORTYPE; 

	return ret;
}

flag asn1SccExecutionCompletionErrorType_Encode(const asn1SccExecutionCompletionErrorType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccExecutionCompletionErrorType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1SccunknownExecutionCompletionError:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case asn1SccchecksumFailed:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case asn1SccaddressOutOfRange:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_EXECUTIONCOMPLETIONERRORTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccExecutionCompletionErrorType_Decode(asn1SccExecutionCompletionErrorType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_EXECUTIONCOMPLETIONERRORTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1SccunknownExecutionCompletionError;
	                break;
	            case 1: 
	                (*(pVal)) = asn1SccchecksumFailed;
	                break;
	            case 2: 
	                (*(pVal)) = asn1SccaddressOutOfRange;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_EXECUTIONCOMPLETIONERRORTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1SccunknownExecutionCompletionError;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccExecutionCompletionErrorType_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccExecutionCompletionErrorType_ACN_Encode(const asn1SccExecutionCompletionErrorType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccExecutionCompletionErrorType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1SccunknownExecutionCompletionError:
	            uIntVal = 0;
	            break;
	        case asn1SccchecksumFailed:
	            uIntVal = 1;
	            break;
	        case asn1SccaddressOutOfRange:
	            uIntVal = 2;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_EXECUTIONCOMPLETIONERRORTYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 2);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccExecutionCompletionErrorType_ACN_Decode(asn1SccExecutionCompletionErrorType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_EXECUTIONCOMPLETIONERRORTYPE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1SccunknownExecutionCompletionError;
	            break;
	        case 1:
	            (*(pVal)) = asn1SccchecksumFailed;
	            break;
	        case 2:
	            (*(pVal)) = asn1SccaddressOutOfRange;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_EXECUTIONCOMPLETIONERRORTYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccExecutionCompletionErrorType_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int32_Equal(const asn1SccT_Int32* pVal1, const asn1SccT_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

flag asn1SccT_Int32_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int32_ACN_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_ACN_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt32_Equal(const asn1SccT_UInt32* pVal1, const asn1SccT_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

flag asn1SccT_UInt32_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt32_ACN_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_ACN_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int8_Equal(const asn1SccT_Int8* pVal1, const asn1SccT_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

flag asn1SccT_Int8_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int8_ACN_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_ACN_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt8_Equal(const asn1SccT_UInt8* pVal1, const asn1SccT_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

flag asn1SccT_UInt8_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt8_ACN_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_ACN_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Boolean_Equal(const asn1SccT_Boolean* pVal1, const asn1SccT_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_Boolean_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Boolean_ACN_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_ACN_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Null_Record_Equal(const asn1SccT_Null_Record* pVal1, const asn1SccT_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

void asn1SccT_Null_Record_Initialize(asn1SccT_Null_Record* pVal)
{
	(void)pVal;


}

flag asn1SccT_Null_Record_IsConstraintValid(const asn1SccT_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_Null_Record_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Null_Record_ACN_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_ACN_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

