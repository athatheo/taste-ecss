pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");
pragma Warnings (On, "redundant with clause in body");

package body TASTE_BasicTypes with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccT_Int32_Equal (val1, val2 :  asn1SccT_Int32) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_Int32_Equal;

function asn1SccT_Int32_Init return asn1SccT_Int32
is
    val: asn1SccT_Int32;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Int32_Init;

function asn1SccT_Int32_IsConstraintValid(val : asn1SccT_Int32) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := ((-2147483648 <= val) AND (val <= 2147483647));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_INT32);
    return ret;
end asn1SccT_Int32_IsConstraintValid;



function asn1SccT_UInt32_Equal (val1, val2 :  asn1SccT_UInt32) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_UInt32_Equal;

function asn1SccT_UInt32_Init return asn1SccT_UInt32
is
    val: asn1SccT_UInt32;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UInt32_Init;

function asn1SccT_UInt32_IsConstraintValid(val : asn1SccT_UInt32) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 4294967295);
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_UINT32);
    return ret;
end asn1SccT_UInt32_IsConstraintValid;



function asn1SccT_Int8_Equal (val1, val2 :  asn1SccT_Int8) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_Int8_Equal;

function asn1SccT_Int8_Init return asn1SccT_Int8
is
    val: asn1SccT_Int8;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Int8_Init;

function asn1SccT_Int8_IsConstraintValid(val : asn1SccT_Int8) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := ((-128 <= val) AND (val <= 127));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_INT8);
    return ret;
end asn1SccT_Int8_IsConstraintValid;



function asn1SccT_UInt8_Equal (val1, val2 :  asn1SccT_UInt8) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_UInt8_Equal;

function asn1SccT_UInt8_Init return asn1SccT_UInt8
is
    val: asn1SccT_UInt8;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UInt8_Init;

function asn1SccT_UInt8_IsConstraintValid(val : asn1SccT_UInt8) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 255);
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_UINT8);
    return ret;
end asn1SccT_UInt8_IsConstraintValid;



function asn1SccT_Boolean_Equal (val1, val2 :  asn1SccT_Boolean) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_Boolean_Equal;

function asn1SccT_Boolean_Init return asn1SccT_Boolean
is
    val: asn1SccT_Boolean;
begin
    val := FALSE;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Boolean_Init;

function asn1SccT_Boolean_IsConstraintValid(val : asn1SccT_Boolean) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end asn1SccT_Boolean_IsConstraintValid;



function asn1SccT_Null_Record_Equal (val1, val2 :  asn1SccT_Null_Record) return Boolean
is
   pragma Unreferenced (val1);
   pragma Unreferenced (val2);

begin
	return True;

end asn1SccT_Null_Record_Equal;

function asn1SccT_Null_Record_Init return asn1SccT_Null_Record
is
    val: asn1SccT_Null_Record;
begin
    val := (null record);
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Null_Record_Init;

function asn1SccT_Null_Record_IsConstraintValid(val : asn1SccT_Null_Record) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end asn1SccT_Null_Record_IsConstraintValid;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end TASTE_BasicTypes;