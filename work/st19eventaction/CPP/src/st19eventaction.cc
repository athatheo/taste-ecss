// Body file for function ST19EventAction
// Generated by TASTE on 2021-05-18 21:17:22
// You can edit this file, it will not be overwritten
// Provided interfaces : TC19
// Required interfaces : 
// User-defined properties for this function:
//   |_ Taste::Active_Interfaces = any
//   |_ Taste::coordinates = 151502 101264 190838 113113
// Timers              : 

#include "st19eventaction.h"
#include "st19eventaction_state.h"
//#include <iostream>

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere

/* User code: This file will not be overwritten by TASTE. */
#include <stdint.h>
#include <map>
#include <string>
#include "math.h"
#include "iostream"

#define ECSS_TC_REQUEST_STRING_SIZE 64
st19eventaction_state ctxt_st19eventaction;

void addEventActionDefinitions(const asn1SccMessage*);
void disableEventActionFunction(const asn1SccMessage*);
void enableEventActionFunction(const asn1SccMessage*);
void eventActionStatusReport();
void requestEventActionDefinitionStatus(const asn1SccMessage*);
void disableEventActionDefinitions(const asn1SccMessage*);
void enableEventActionDefinitions(const asn1SccMessage*);
void deleteAllEventActionDefinitions(const asn1SccMessage*);
void deleteEventActionDefinitions(const asn1SccMessage*);
void addEventActionDefinitions(const asn1SccMessage*);
void setEventActionFunctionStatus(bool);
bool getEventActionFunctionStatus();
bool eventActionFunctionStatus;
const asn1SccMessage* parseECSSTC(uint8_t*);

struct EventActionDefinition {
	// TODO: APID = 0 is the Ground Station APID. This should be changed
	uint16_t applicationId = 0;
	uint16_t eventDefinitionID = 65535; // The ID of the event that might take place
	uint16_t eventActionDefinitionID = 0; // The ID of the event-action
	std::string request = "";
	bool enabled = false;
};

std::map<uint16_t, EventActionDefinition> eventActionDefinitionMap;
void st19eventaction_startup()
{
    	eventActionFunctionStatus = true;
}

void st19eventaction_PI_TC19(const asn1SccMessage *IN_message)
{
    switch (IN_message->messageType) {
		case 1:
			addEventActionDefinitions(IN_message);
            break;
        case 2:
			deleteEventActionDefinitions(IN_message); // TC[19,2]
			break;
		case 3:
			deleteAllEventActionDefinitions(IN_message); // TC[19,3]
			break;
		case 4:
			enableEventActionDefinitions(IN_message); // TC[19,4]
			break;
		case 5:
			disableEventActionDefinitions(IN_message); // TC[19,5]
			break;
		case 6:
			requestEventActionDefinitionStatus(IN_message); // TC[19,6]
			break;
		case 8:
			enableEventActionFunction(IN_message); // TC[19,8]
			break;
		case 9:
			disableEventActionFunction(IN_message); // TC[19,9]
			break;
	}
}


void addEventActionDefinitions(const asn1SccMessage* message) {
	// TC[19,1]
	int counter = 0;
	uint16_t applicationID = message->data.arr[counter];
	counter++;
	uint16_t eventDefinitionID = message->data.arr[counter];
	counter++;
	uint16_t eventActionDefinitionID = message->data.arr[counter];
	bool canBeAdded = true;
	if (eventActionDefinitionMap.find(eventDefinitionID) != eventActionDefinitionMap.end()) {
		auto range = eventActionDefinitionMap.equal_range(eventDefinitionID);
		for (auto& element = range.first; element != range.second; ++element) {
			if (element->second.eventActionDefinitionID == eventActionDefinitionID) {
				canBeAdded = false;
			}
		}
	}
	if ((message->dataSize - 6) > ECSS_TC_REQUEST_STRING_SIZE) {
		canBeAdded = false;
	}
	if (canBeAdded) {
		char data[ECSS_TC_REQUEST_STRING_SIZE] = { 0 };
		int counter = 0;
		int length = ECSS_TC_REQUEST_STRING_SIZE;
		for (int i = 0; i < length/2; i++){
			data[counter] = message->data.arr[i]/pow(2,7);
			data[counter+1] = message->data.arr[i]%(int)pow(2,7);
			counter+=2;	
		}		
		EventActionDefinition temp;
		temp.enabled = false;
		temp.applicationId = applicationID;
		temp.eventDefinitionID = eventDefinitionID;
		temp.eventActionDefinitionID = eventActionDefinitionID;
		temp.request = std::string(data);
		eventActionDefinitionMap.insert(std::make_pair(eventDefinitionID, temp));
	}
	
	std::cout << "TC[19,01]" << std::endl;
}


void execute(const asn1SccMessage* message){
	switch (message->serviceType) {
		case 5:
			st19eventaction_RI_EventActionTC05(message); // ST[05]
			break;
		case 8:
			st19eventaction_RI_EventActionTC08(message); // ST[08]
			break;
		case 11:
			//st19eventaction_RI_EventActionTC11(&message); // ST[11]
			break;
		case 20:
			//st19eventaction_RI_EventActionTC20(&message); // ST[20]
			break;
	}
}

void executeAction(uint16_t eventID) {
	// Custom function
	if (eventActionFunctionStatus) {
		auto range = eventActionDefinitionMap.equal_range(eventID);
		for (auto& element = range.first; element != range.second; ++element) {
			if (element->second.enabled) {
				uint8_t* data = (uint8_t*)element->second.request.c_str();
				const asn1SccMessage* message = parseECSSTC(data);
				execute(message);
			}
		}
	}
}

void disableEventActionFunction(const asn1SccMessage* message) {
	// TC[19,9]
	setEventActionFunctionStatus(false);
    std::cout << "TC[19,09]" << std::endl;
}

void enableEventActionFunction(const asn1SccMessage* message) {
	// TC[19,8]

	setEventActionFunctionStatus(true);
    std::cout << "TC[19,08]" << std::endl;

}

void eventActionStatusReport() {
	// TM[19,7]
	asn1SccMessage report;
	report.packetType = asn1SccMessage_packetType(0);
    	report.serviceType = 19;
    	report.messageType = 7;

	uint16_t count = eventActionDefinitionMap.size();
	report.data.arr[0]=(count);
	int counter = 0;
	for (const auto& element : eventActionDefinitionMap) {
		report.data.arr[counter+1] = element.second.applicationId;
		report.data.arr[counter+2] = (element.second.eventDefinitionID);
		report.data.arr[counter+3] = (element.second.eventActionDefinitionID);
		report.data.arr[counter+4] = (element.second.enabled);
		counter = counter + 4;
	}
    std::cout << "TM[19,07]" << std::endl;
	//storeMessage(report);
}

void requestEventActionDefinitionStatus(const asn1SccMessage* message) {
	// TC[19,6]
    std::cout << "TC[19,06]" << std::endl;
	eventActionStatusReport();
}

void disableEventActionDefinitions(const asn1SccMessage* message) {
	// TC[19,5]
	int counter = 0;
	uint16_t numberOfEventActionDefinitions = message->data.arr[counter];
	counter++;
	if (numberOfEventActionDefinitions != 0U) {
		for (uint16_t i = 0; i < numberOfEventActionDefinitions; i++) {
			counter++;// Skips reading applicationID
			uint16_t eventDefinitionID = message->data.arr[counter];
			counter++;
			uint16_t eventActionDefinitionID = message->data.arr[counter];
			counter++;
			if (eventActionDefinitionMap.find(eventDefinitionID) != eventActionDefinitionMap.end()) {
				bool definitionIDexists = false;
                		auto range = eventActionDefinitionMap.equal_range(eventDefinitionID);
				for (auto& element = range.first; element != range.second; ++element) {
					if (element->second.eventActionDefinitionID == eventActionDefinitionID) {
						element->second.enabled = false;
						definitionIDexists = true;
					}
				}
			}
		}
	} else {
		for (auto& element : eventActionDefinitionMap) {
			element.second.enabled = false;
		}
	}
    std::cout << "TC[19,05]" << std::endl;
}

void enableEventActionDefinitions(const asn1SccMessage* message) {
	// TC[19,4]
	int counter = 0;
	uint16_t numberOfEventActionDefinitions = message->data.arr[counter];
	counter++;
	if (numberOfEventActionDefinitions != 0U) {
		for (uint16_t i = 0; i < numberOfEventActionDefinitions; i++) {

			counter++;// Skips reading applicationID
			uint16_t eventDefinitionID = message->data.arr[counter];
			counter++;
			uint16_t eventActionDefinitionID = message->data.arr[counter];
			counter++;
            if (eventActionDefinitionMap.find(eventDefinitionID) != eventActionDefinitionMap.end()) {
				bool definitionIDexists = false;
				auto range = eventActionDefinitionMap.equal_range(eventDefinitionID);
				for (auto& element = range.first; element != range.second; ++element) {
					if (element->second.eventActionDefinitionID == eventActionDefinitionID) {
						element->second.enabled = true;
						definitionIDexists = true;
						break;
					}
				}
			}
		}
	} else {
		for (auto& element : eventActionDefinitionMap) {
			element.second.enabled = true;
		}
	}
    std::cout << "TC[19,04]" << std::endl;

}

void deleteAllEventActionDefinitions(const asn1SccMessage* message) {
	// TC[19,3]

	setEventActionFunctionStatus(false);
	eventActionDefinitionMap.clear();
    std::cout << "TC[19,03]" << std::endl;
}

void deleteEventActionDefinitions(const asn1SccMessage* message) {
	int counter = 0;
	uint16_t numberOfEventActionDefinitions = message->data.arr[counter];
	bool definitionIDexists = false;
	for (uint16_t i = 0; i < numberOfEventActionDefinitions; i++) {

		counter++;
		uint16_t eventDefinitionID = message->data.arr[counter];
		counter++;
		uint16_t eventActionDefinitionID = message->data.arr[counter];
		counter++;
		if (eventActionDefinitionMap.find(eventDefinitionID) != eventActionDefinitionMap.end()) {
			auto range = eventActionDefinitionMap.equal_range(eventDefinitionID);
			for (auto& element = range.first; element != range.second; ++element) {
				if (element->second.eventActionDefinitionID == eventActionDefinitionID) {
					definitionIDexists = true;
					if (!element->second.enabled) {
						eventActionDefinitionMap.erase(element);
					}
				}
			}
		}
	}
	std::cout << "TC[19,02]" << std::endl;
}

void setEventActionFunctionStatus(bool status) {
	eventActionFunctionStatus = status;
}


bool getEventActionFunctionStatus() {
	return eventActionFunctionStatus;
}

const asn1SccMessage* parseECSSTC(uint8_t* data){
	asn1SccMessage* message;
	message->packetType = asn1SccMessage_packetType(1);
	int length = ECSS_TC_REQUEST_STRING_SIZE;
	uint8_t pusVersion = data[0] >> 4;
	uint8_t serviceType = data[1];
	uint8_t messageType = data[2];


	// Remove the length of the header
	length -= 5;


	message->serviceType = serviceType;
	message->messageType = messageType;
	int counter = 0;
	for (int i = 0; i < length/2; i++){
		message->data.arr[i] = pow(2,7)*data[counter]+data[counter+1];
		counter++;	
	}
	message->dataSize = length;
	return const_cast<const asn1SccMessage*>(message);
}
