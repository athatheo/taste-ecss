// Body file for function ST08FunctionManagement
// Generated by TASTE on 2021-05-18 20:49:18
// You can edit this file, it will not be overwritten
// Provided interfaces : TC08
// Required interfaces : 
// User-defined properties for this function:
//   |_ Taste::Active_Interfaces = any
//   |_ Taste::coordinates = 151344 68405 191312 81201
// Timers              : 

#include "st08functionmanagement.h"
#include "st08functionmanagement_state.h"
//#include <iostream>

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere

/* User code: This file will not be overwritten by TASTE. */

#include "string"
#include "iostream"
#include "map"
#define ECSS_FUNCTION_NAME_LENGTH 32
#define ECSS_FUNCTION_MAX_ARG_LENGTH 32
#define DEBUG 1
st08functionmanagement_state ctxt_st08functionmanagement;

class FunctionManagementService;
typedef std::map<std::string, void (*)(std::string)> FunctionMap;
FunctionMap funcPtrIndex;

void call(const asn1SccMessage*);
void include(std::string, void (* ptr)(std::string));

void st08functionmanagement_startup()
{
    /* Write your initialization code here,
       but do not make any call to a required interface. */
}

void st08functionmanagement_PI_TC08(const asn1SccMessage *IN_message)
{
    	switch (IN_message->messageType) {
		case 1:
			call(IN_message); // TC[8,1]
			break;
		default:

			break;
	}
}

void st08functionmanagement_PI_EventActionTC08(const asn1SccMessage *IN_message)
{
    	switch (IN_message->messageType) {
		case 1:
			call(IN_message); // TC[8,1]
			break;
		default:
			break;
	}
}

void call(const asn1SccMessage* msg) {
	uint8_t funcName[ECSS_FUNCTION_NAME_LENGTH] = { 0 }; // the function's name
	uint8_t funcArgs[ECSS_FUNCTION_MAX_ARG_LENGTH] = { 0 }; // arguments for the function
	for (uint16_t i = 0; i<ECSS_FUNCTION_NAME_LENGTH; i++){
            funcName[i]=msg->data.arr[i];
        }
	for (uint16_t i = ECSS_FUNCTION_NAME_LENGTH; i<ECSS_FUNCTION_MAX_ARG_LENGTH; i++){
            funcArgs[i]=msg->data.arr[i];
        }

	// locate the appropriate function pointer
	std::string name = (char*)funcName;
	std::string args = (char*)funcArgs;
	FunctionMap::iterator iter = funcPtrIndex.find(name);
	void (*selected)(std::string);

	if (iter != funcPtrIndex.end()) {
		std::cout << *iter->second; 
		selected = *iter->second;
	}
	// execute the function if there are no obvious flaws (defined in the standard, pg.158)
#if DEBUG
    std::cout << "TC[08,01]" << std::endl;
#else
    selected(args);
#endif
}

void include(std::string funcName, void (* ptr)(std::string)) {
		funcName.append(ECSS_FUNCTION_NAME_LENGTH - funcName.length(), 0);
		funcPtrIndex.insert(std::make_pair(funcName, ptr));
}
