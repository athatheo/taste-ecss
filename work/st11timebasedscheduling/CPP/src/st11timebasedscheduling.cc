// Body file for function ST11TimeBasedScheduling
// Generated by TASTE on 2021-05-18 21:17:22
// You can edit this file, it will not be overwritten
// Provided interfaces : TC11
// Required interfaces : 
// User-defined properties for this function:
//   |_ Taste::Active_Interfaces = any
//   |_ Taste::coordinates = 151502 84993 191312 98105
// Timers              : 

#include "st11timebasedscheduling.h"
#include "st11timebasedscheduling_state.h"
//#include <iostream>

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere


#include "algorithm"
#include "list"
#include <stdint.h>
#include "math.h"
#include <cstdint>
#include <ctime>
#include <stdio.h>
#include <cstring>
#include <string>
#include "iostream"
#define ECSS_MAX_NUMBER_OF_TIME_SCHED_ACTIVITIES 10
#define ECSS_TC_REQUEST_STRING_SIZE 64
#define ECSS_PUS_VERSION 2
#define ECSS_MAX_MESSAGE_SIZE 1024U
#define CCSDS_MAX_MESSAGE_SIZE (ECSS_MAX_MESSAGE_SIZE + 6u + 6u + 2u)
static bool executionFunctionStatus = false; // True indicates "enabled" and False "disabled" state
st11timebasedscheduling_state ctxt_st11timebasedscheduling;

struct RequestID {
	uint16_t applicationID = 0; ///< Application process ID
	uint16_t sequenceCount = 0; ///< Packet sequence count
	uint16_t sourceID = 0; ///< Packet source ID

	bool operator!=(const RequestID& rightSide) const {
		return (sequenceCount != rightSide.sequenceCount) or (applicationID != rightSide.applicationID) or
		       (sourceID != rightSide.sourceID);
	}
};

struct ScheduledActivity {
	asn1SccMessage request; ///< Hold the received command request
	RequestID requestID; ///< Request ID, characteristic of the definition
	uint32_t requestReleaseTime = 0; ///< Keep the command release time
};

std::list<ScheduledActivity> scheduledActivities;

void enableScheduleExecution(const asn1SccMessage*);
void disableScheduleExecution(const asn1SccMessage*);
void resetSchedule(const asn1SccMessage*);
void insertActivities(const asn1SccMessage*);
void timeShiftAllActivities(const asn1SccMessage*);
void timeShiftActivitiesByID(const asn1SccMessage*);
void deleteActivitiesByID(const asn1SccMessage*);
void detailReportAllActivities(const asn1SccMessage*);
void summaryReportActivitiesByID(const asn1SccMessage*);
void detailReportActivitiesByID(const asn1SccMessage*);
void sortActivitiesReleaseTime();
asn1SccMessage parseTC(uint8_t*);
uint16_t* composeECSS(asn1SccMessage);
uint32_t getSeconds();
void st11timebasedscheduling_startup()
{
    /* Write your initialization code here,
       but do not make any call to a required interface. */
}

void st11timebasedscheduling_PI_TC11(const asn1SccMessage *IN_message)
{
        switch (IN_message->messageType) {
		case 1:
			enableScheduleExecution(IN_message); // TC[11,1]
			break;
		case 2:
			disableScheduleExecution(IN_message); // TC[11,2]
			break;
		case 3:
			resetSchedule(IN_message); // TC[11,3]
			break;
		case 4:
			insertActivities(IN_message); // TC[11,4]
			break;
		case 5:
			deleteActivitiesByID(IN_message); // TC[11,5]
			break;
		case 7:
			timeShiftActivitiesByID(IN_message); // TC[11,7]
			break;
		case 9:
			detailReportActivitiesByID(IN_message); // TC[11,9]
			break;
		case 12:
			summaryReportActivitiesByID(IN_message); // TC[11,12]
			break;
		case 15:
			timeShiftAllActivities(IN_message); // TC[11,15]
			break;
		case 16:
			detailReportAllActivities(IN_message); // TC[11,16]
			break;
	}
}

void st11timebasedscheduling_PI_EventActionTC11(const asn1SccMessage *IN_message)
{
        switch (IN_message->messageType) {
		case 1:
			enableScheduleExecution(IN_message); // TC[11,1]
			break;
		case 2:
			disableScheduleExecution(IN_message); // TC[11,2]
			break;
		case 3:
			resetSchedule(IN_message); // TC[11,3]
			break;
		case 4:
			insertActivities(IN_message); // TC[11,4]
			break;
		case 5:
			deleteActivitiesByID(IN_message); // TC[11,5]
			break;
		case 7:
			timeShiftActivitiesByID(IN_message); // TC[11,7]
			break;
		case 9:
			detailReportActivitiesByID(IN_message); // TC[11,9]
			break;
		case 12:
			summaryReportActivitiesByID(IN_message); // TC[11,12]
			break;
		case 15:
			timeShiftAllActivities(IN_message); // TC[11,15]
			break;
		case 16:
			detailReportAllActivities(IN_message); // TC[11,16]
			break;
	}
}

void enableScheduleExecution(const asn1SccMessage* request) {

	executionFunctionStatus = true; // Enable the service
	std::cout << "TC[11,01]" << std::endl;
}

void disableScheduleExecution(const asn1SccMessage* request) {
	executionFunctionStatus = false; // Disable the service
    std::cout << "TC[11,02]" << std::endl;
}

void resetSchedule(const asn1SccMessage* request) {
	scheduledActivities.clear();
    std::cout << "TC[11,03]" << std::endl;
}

void insertActivities(const asn1SccMessage* request) {
	uint16_t iterationCount = request->data.arr[0]; // Get the iteration count, (N)
	while (iterationCount-- != 0) {
		// todo: Get the group ID first, if groups are used
		uint32_t currentTime = getSeconds(); // Get the current system time

		uint32_t releaseTime = request->data.arr[1]*pow(2,15)+request->data.arr[2]; // Get the specified release time
			// Get the TC packet request
			uint8_t requestData[ECSS_TC_REQUEST_STRING_SIZE] = {0};
			for (int i = 0; i < ECSS_TC_REQUEST_STRING_SIZE; i++){
				requestData[i] = request->data.arr[i];			
			}
			asn1SccMessage receivedTCPacket = parseTC(requestData);
			ScheduledActivity newActivity; // Create the new activity

			// Assign the attributes to the newly created activity
			newActivity.request = receivedTCPacket;
			newActivity.requestReleaseTime = releaseTime;

			newActivity.requestID.applicationID = request->applicationId;
			newActivity.requestID.sequenceCount = request->packetSequenceCount;

			scheduledActivities.push_back(newActivity); // Insert the new activities
	}
	sortActivitiesReleaseTime(); // Sort activities by their release time
    std::cout << "TC[11,04]" << std::endl;
}

void timeShiftAllActivities(const asn1SccMessage* request) {

	uint32_t current_time = getSeconds(); // Get the current system time

	const auto releaseTimes =
	    std::minmax_element(scheduledActivities.begin(), scheduledActivities.end(),
	                        [](ScheduledActivity const& leftSide, ScheduledActivity const& rightSide) {
		                        return leftSide.requestReleaseTime < rightSide.requestReleaseTime;
	                        });
	// todo: Define what the time format is going to be
	int32_t relativeOffset = request->data.arr[0]*pow(2,15)+request->data.arr[1]; // Get the relative offset
	for (auto& activity : scheduledActivities) {
		activity.requestReleaseTime += relativeOffset; // Time shift each activity
	}
	std::cout << "TC[11,15]" << std::endl;
}

void timeShiftActivitiesByID(const asn1SccMessage* request) {

	uint32_t current_time = getSeconds(); // Get the current system time

	int32_t relativeOffset = request->data.arr[0]*pow(2,15)+request->data.arr[1]; // Get the offset first
	uint16_t iterationCount = request->data.arr[2]; // Get the iteration count, (N)
	int counter=3;
	while (iterationCount-- != 0) {
		// Parse the request ID
		RequestID receivedRequestID; // Save the received request ID
		receivedRequestID.sourceID = request->data.arr[counter]; // Get the source ID
		counter++;
		receivedRequestID.applicationID = request->applicationId; // Get the application ID
		receivedRequestID.sequenceCount = request->packetSequenceCount; // Get the sequence count

		// Try to find the activity with the requested request ID
		auto requestIDMatch = std::find_if_not(scheduledActivities.begin(), scheduledActivities.end(),
		                                       [&receivedRequestID](ScheduledActivity const& currentElement) {
			                                       return receivedRequestID != currentElement.requestID;
		                                       });

		if (requestIDMatch != scheduledActivities.end()) {
			requestIDMatch->requestReleaseTime += relativeOffset; // Add the time offset
		} 
	}
	sortActivitiesReleaseTime(); // Sort activities by their release time
    std::cout << "TC[11,07]" << std::endl;
}

void deleteActivitiesByID(const asn1SccMessage* request) {
    
	uint16_t iterationCount = request->data.arr[0]; // Get the iteration count, (N)
	int counter=1;
	while (iterationCount-- != 0) {
		// Parse the request ID
		RequestID receivedRequestID; // Save the received request ID
		receivedRequestID.sourceID = request->data.arr[counter]; // Get the source ID
		counter++;
		receivedRequestID.applicationID = request->applicationId; // Get the application ID
		receivedRequestID.sequenceCount = request->packetSequenceCount; // Get the sequence count

		// Try to find the activity with the requested request ID
		const auto requestIDMatch = std::find_if_not(scheduledActivities.begin(), scheduledActivities.end(),
		                                             [&receivedRequestID](ScheduledActivity const& currentElement) {
			                                             return receivedRequestID != currentElement.requestID;
		                                             });

		if (requestIDMatch != scheduledActivities.end()) {
			scheduledActivities.erase(requestIDMatch); // Delete activity from the schedule
		}
	}
	std::cout << "TC[11,05]" << std::endl;
}

void detailReportAllActivities(const asn1SccMessage* request) {

	// Create the report message object of telemetry message subtype 10 for each activity
	asn1SccMessage report;
	report.packetType = asn1SccMessage_packetType(0);
    	report.serviceType = 11;
    	report.messageType = 10;
	report.data.arr[0] = (static_cast<uint16_t>(scheduledActivities.size()));
	int counter = 1;
	for (auto& activity : scheduledActivities) {
		// todo: append sub-schedule and group ID if they are defined

		report.data.arr[counter]=(activity.requestReleaseTime)/2;
		report.data.arr[counter+1]=activity.requestReleaseTime%2;
		counter++;
		uint16_t* temp_string = composeECSS(activity.request);
		for (int i = 0; i < CCSDS_MAX_MESSAGE_SIZE; i++){
			report.data.arr[counter+i]=temp_string[i];
		}
		counter = counter + CCSDS_MAX_MESSAGE_SIZE;

	}
	std::cout << "TC[11,16]" << std::endl;
	//storeMessage(report); // Save the report
}

void detailReportActivitiesByID(const asn1SccMessage* request) {

	// Create the report message object of telemetry message subtype 10 for each activity
	asn1SccMessage report;
	report.packetType = asn1SccMessage_packetType(0);
    	report.serviceType = 11;
    	report.messageType = 10;
	std::list<ScheduledActivity> matchedActivities;

	uint16_t iterationCount = request->data.arr[0]; // Get the iteration count, (N)
	int counter=1;
	while (iterationCount-- != 0) {
		// Parse the request ID
		RequestID receivedRequestID; // Save the received request ID
		receivedRequestID.sourceID = request->data.arr[counter]; // Get the source ID
		counter++;
		receivedRequestID.applicationID = request->applicationId; // Get the application ID
		receivedRequestID.sequenceCount = request->packetSequenceCount; // Get the sequence count

		// Try to find the activity with the requested request ID
		const auto requestIDMatch = std::find_if_not(scheduledActivities.begin(), scheduledActivities.end(),
		                                             [&receivedRequestID](ScheduledActivity const& currentElement) {
			                                             return receivedRequestID != currentElement.requestID;
		                                             });

		if (requestIDMatch != scheduledActivities.end()) {
			matchedActivities.push_back(*requestIDMatch); // Save the matched activity
		}
	}

	sortActivitiesReleaseTime(); // Sort activities by their release time

	// todo: append sub-schedule and group ID if they are defined
	counter++;
	report.data.arr[counter]=(static_cast<uint16_t>(matchedActivities.size()));
	for (auto& match : matchedActivities) {
		counter++;
		report.data.arr[counter] = match.requestReleaseTime/2;
		counter++;
		report.data.arr[counter] = match.requestReleaseTime%2;
		counter++;
		uint16_t* temp_string = composeECSS(match.request);
		for (int i = 0; i < CCSDS_MAX_MESSAGE_SIZE; i++){
			report.data.arr[counter+i]=temp_string[i];
		}
		counter = counter + CCSDS_MAX_MESSAGE_SIZE;
	}
	std::cout << "TC[11,09]" << std::endl;
	//storeMessage(report); // Save the report
}

void summaryReportActivitiesByID(const asn1SccMessage* request) {
	// Create the report message object of telemetry message subtype 13 for each activity
	asn1SccMessage report;
	report.packetType = asn1SccMessage_packetType(0);
    	report.serviceType = 11;
    	report.messageType = 13;
	std::list<ScheduledActivity> matchedActivities;

	uint16_t iterationCount = request->data.arr[0]; // Get the iteration count, (N)
	int counter = 1;
	while (iterationCount-- != 0) {
		// Parse the request ID
		RequestID receivedRequestID; // Save the received request ID
		receivedRequestID.sourceID = request->data.arr[counter]; // Get the source ID
		counter++;
		receivedRequestID.applicationID = request->applicationId; // Get the application ID
		receivedRequestID.sequenceCount = request->packetSequenceCount; // Get the sequence count

		// Try to find the activity with the requested request ID
		auto requestIDMatch = std::find_if_not(scheduledActivities.begin(), scheduledActivities.end(),
		                                       [&receivedRequestID](ScheduledActivity const& currentElement) {
			                                       return receivedRequestID != currentElement.requestID;
		                                       });

		if (requestIDMatch != scheduledActivities.end()) {
			matchedActivities.push_back(*requestIDMatch);
		}
	}

	sortActivitiesReleaseTime(); // Sort activities by their release time
	counter++;
	report.data.arr[counter]=(static_cast<uint16_t>(matchedActivities.size()));
	for (auto& match : matchedActivities) {
		counter++;
		report.data.arr[counter]=match.requestReleaseTime/2;
		counter++;
		report.data.arr[counter]=match.requestReleaseTime%2;
		counter++;
		report.data.arr[counter]=match.requestID.sourceID;
		report.applicationId = match.requestID.applicationID;
		report.packetSequenceCount = match.requestID.sequenceCount;
	}
	std::cout << "TC[11,12]" << std::endl;
	//storeMessage(report); // Save the report
}

void sortActivitiesReleaseTime() {
		scheduledActivities.sort([](ScheduledActivity const& leftSide, ScheduledActivity const& rightSide) {
			return leftSide.requestReleaseTime < rightSide.requestReleaseTime;
		});
	}

asn1SccMessage parseTC(uint8_t* data){
	asn1SccMessage message;
	message.packetType = asn1SccMessage_packetType(1);
	int length = ECSS_TC_REQUEST_STRING_SIZE;
	uint8_t pusVersion = data[0] >> 4;
	uint8_t serviceType = data[1];
	uint8_t messageType = data[2];


	// Remove the length of the header
	length -= 5;


	message.serviceType = serviceType;
	message.messageType = messageType;
	int counter = 0;
	for (int i = 0; i < length/2; i++){
		message.data.arr[i] = pow(2,7)*data[counter]+data[counter+1];
		counter+=2;	
	}
	message.dataSize = length;
	return message;
}

uint16_t* composeECSS(asn1SccMessage message){
	uint8_t header[5];

	if (message.packetType == asn1SccMessage_packetType(1)) {
		header[0] = ECSS_PUS_VERSION << 4U; // Assign the pusVersion = 2
		header[1] = message.serviceType;
		header[2] = message.messageType;
		header[3] = 0;
		header[4] = 0;
	} else {
		header[0] = ECSS_PUS_VERSION << 4U; // Assign the pusVersion = 2
		header[1] = message.serviceType;
		header[2] = message.messageType;
		header[3] = static_cast<uint8_t>(message.messageTypeCounter >> 8U);
		header[4] = static_cast<uint8_t>(message.messageTypeCounter & 0xffU);
	}
	uint8_t data[CCSDS_MAX_MESSAGE_SIZE];
	data[0]=header[0];
	data[1]=header[1];
	data[2]=header[2];
	data[3]=header[3];
	data[4]=header[4];
	for (int i = 5; i < CCSDS_MAX_MESSAGE_SIZE; i++){
		if (i>(message.dataSize+5)){
			data[i] = 0;	
		} else {
			data[i] = message.data.arr[i-5];		
		}
	}
	uint16_t dataString[CCSDS_MAX_MESSAGE_SIZE];
	int counter = 0;
	for (int i = 0; i < CCSDS_MAX_MESSAGE_SIZE/2; i++){
		dataString[i] = data[counter]*pow(2,7)+data[counter+1];
		counter +=2;
	}
	return dataString;
}


uint32_t getSeconds() {
	return static_cast<uint32_t>(time(nullptr));
}



