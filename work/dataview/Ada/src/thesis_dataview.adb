pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");
pragma Warnings (On, "redundant with clause in body");

package body THESIS_DATAVIEW with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccMyInteger_Equal (val1, val2 :  asn1SccMyInteger) return Boolean
is

begin
	return val1 = val2;

end asn1SccMyInteger_Equal;

function asn1SccMyInteger_Init return asn1SccMyInteger
is
    val: asn1SccMyInteger;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMyInteger_Init;

function asn1SccMyInteger_IsConstraintValid(val : asn1SccMyInteger) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 10000);
    ret.ErrorCode := (if ret.Success then 0 else ERR_MYINTEGER);
    return ret;
end asn1SccMyInteger_IsConstraintValid;



function asn1SccUInt8_Equal (val1, val2 :  asn1SccUInt8) return Boolean
is

begin
	return val1 = val2;

end asn1SccUInt8_Equal;

function asn1SccUInt8_Init return asn1SccUInt8
is
    val: asn1SccUInt8;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccUInt8_Init;

function asn1SccUInt8_IsConstraintValid(val : asn1SccUInt8) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 255);
    ret.ErrorCode := (if ret.Success then 0 else ERR_UINT8);
    return ret;
end asn1SccUInt8_IsConstraintValid;



function asn1SccPacket_Equal (val1, val2 :  asn1SccPacket) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 100 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccPacket_Equal;

function asn1SccPacket_Init return asn1SccPacket
is
    val: asn1SccPacket;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := asn1SccUInt8_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPacket_Init;

function asn1SccPacket_IsConstraintValid(val : asn1SccPacket) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    i1 := val.Data'First;
    while ret.Success and i1 <= 100 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 100);
        ret := asn1SccUInt8_IsConstraintValid(val.Data(i1));
        i1 := i1+1;
    end loop;
    return ret;
end asn1SccPacket_IsConstraintValid;



function asn1SccUInt16_Equal (val1, val2 :  asn1SccUInt16) return Boolean
is

begin
	return val1 = val2;

end asn1SccUInt16_Equal;

function asn1SccUInt16_Init return asn1SccUInt16
is
    val: asn1SccUInt16;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccUInt16_Init;

function asn1SccUInt16_IsConstraintValid(val : asn1SccUInt16) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 65535);
    ret.ErrorCode := (if ret.Success then 0 else ERR_UINT16);
    return ret;
end asn1SccUInt16_IsConstraintValid;



function asn1SccMessage_packetType_Equal (val1, val2 :  asn1SccMessage_packetType) return Boolean
is

begin
	return val1 = val2;

end asn1SccMessage_packetType_Equal;

function asn1SccMessage_data_Equal (val1, val2 :  asn1SccMessage_data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 1024 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccMessage_data_Equal;

function asn1SccMessage_Equal (val1, val2 :  asn1SccMessage) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccMessage_packetType_Equal(val1.packetType, val2.packetType);

    if ret then
        ret := (val1.serviceType = val2.serviceType);

        if ret then
            ret := (val1.messageType = val2.messageType);

            if ret then
                ret := (val1.applicationId = val2.applicationId);

                if ret then
                    ret := (val1.messageTypeCounter = val2.messageTypeCounter);

                    if ret then
                        ret := (val1.packetSequenceCount = val2.packetSequenceCount);

                        if ret then
                            ret := (val1.dataSize = val2.dataSize);

                            if ret then
                                ret := asn1SccMessage_data_Equal(val1.data, val2.data);

                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccMessage_Equal;

function asn1SccMessage_packetType_Init return asn1SccMessage_packetType
is
    val: asn1SccMessage_packetType;
begin
    val := asn1Scctm;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMessage_packetType_Init;
function asn1SccMessage_data_Init return asn1SccMessage_data
is
    val: asn1SccMessage_data;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 1024 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=1024);
        val.Data(i1) := asn1SccUInt16_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMessage_data_Init;
function asn1SccMessage_Init return asn1SccMessage
is
    val: asn1SccMessage;
begin

    --set packetType 
    val.packetType := asn1SccMessage_packetType_Init;
    --set serviceType 
    val.serviceType := asn1SccUInt8_Init;
    --set messageType 
    val.messageType := asn1SccUInt8_Init;
    --set applicationId 
    val.applicationId := asn1SccUInt16_Init;
    --set messageTypeCounter 
    val.messageTypeCounter := asn1SccUInt16_Init;
    --set packetSequenceCount 
    val.packetSequenceCount := asn1SccUInt16_Init;
    --set dataSize 
    val.dataSize := asn1SccUInt16_Init;
    --set data 
    val.data := asn1SccMessage_data_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMessage_Init;

function asn1SccMessage_IsConstraintValid(val : asn1SccMessage) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    ret.Success := (((val.packetType = asn1Scctm)) OR ((val.packetType = asn1Scctc)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_MESSAGE_PACKETTYPE);
    if ret.Success then
        ret := asn1SccUInt8_IsConstraintValid(val.serviceType);
        if ret.Success then
            ret := asn1SccUInt8_IsConstraintValid(val.messageType);
            if ret.Success then
                ret := asn1SccUInt16_IsConstraintValid(val.applicationId);
                if ret.Success then
                    ret := asn1SccUInt16_IsConstraintValid(val.messageTypeCounter);
                    if ret.Success then
                        ret := asn1SccUInt16_IsConstraintValid(val.packetSequenceCount);
                        if ret.Success then
                            ret := asn1SccUInt16_IsConstraintValid(val.dataSize);
                            if ret.Success then
                                i1 := val.data.Data'First;
                                while ret.Success and i1 <= 1024 loop
                                    pragma Loop_Invariant (i1 >= val.data.Data'First and i1 <= 1024);
                                    ret := asn1SccUInt16_IsConstraintValid(val.data.Data(i1));
                                    i1 := i1+1;
                                end loop;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccMessage_IsConstraintValid;



function asn1SccEventOccured_Equal (val1, val2 :  asn1SccEventOccured) return Boolean
is

begin
	return val1 = val2;

end asn1SccEventOccured_Equal;

function asn1SccEventOccured_Init return asn1SccEventOccured
is
    val: asn1SccEventOccured;
begin
    val := asn1SccinformativeUnknownEvent;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccEventOccured_Init;

function asn1SccEventOccured_IsConstraintValid(val : asn1SccEventOccured) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((((((((((((val = asn1SccinformativeUnknownEvent)) OR ((val = asn1SccwwdgReset)))) OR ((val = asn1SccassertionFail)))) OR ((val = asn1SccmCUStart)))) OR ((val = asn1ScclowSeverityUnknownEvent)))) OR ((val = asn1SccmediumSeverityUnknownEvent)))) OR ((val = asn1ScchighSeverityUnknownEvent)))) OR ((val = asn1SccfailedStartOfExecution)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_EVENTOCCURED);
    return ret;
end asn1SccEventOccured_IsConstraintValid;



function asn1SccAcceptanceErrorOccured_Equal (val1, val2 :  asn1SccAcceptanceErrorOccured) return Boolean
is

begin
	return val1 = val2;

end asn1SccAcceptanceErrorOccured_Equal;

function asn1SccAcceptanceErrorOccured_Init return asn1SccAcceptanceErrorOccured
is
    val: asn1SccAcceptanceErrorOccured;
begin
    val := asn1SccunknownAcceptanceError;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccAcceptanceErrorOccured_Init;

function asn1SccAcceptanceErrorOccured_IsConstraintValid(val : asn1SccAcceptanceErrorOccured) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((((((val = asn1SccunknownAcceptanceError)) OR ((val = asn1SccmessageTooShort)))) OR ((val = asn1ScctooManyBitsRead)))) OR ((val = asn1SccstringTooShort)))) OR ((val = asn1SccunacceptableMessage)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_ACCEPTANCEERROROCCURED);
    return ret;
end asn1SccAcceptanceErrorOccured_IsConstraintValid;



function asn1SccRoutingErrorType_Equal (val1, val2 :  asn1SccRoutingErrorType) return Boolean
is

begin
	return val1 = val2;

end asn1SccRoutingErrorType_Equal;

function asn1SccRoutingErrorType_Init return asn1SccRoutingErrorType
is
    val: asn1SccRoutingErrorType;
begin
    val := asn1SccunknownRoutingError;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccRoutingErrorType_Init;

function asn1SccRoutingErrorType_IsConstraintValid(val : asn1SccRoutingErrorType) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val = asn1SccunknownRoutingError);
    ret.ErrorCode := (if ret.Success then 0 else ERR_ROUTINGERRORTYPE);
    return ret;
end asn1SccRoutingErrorType_IsConstraintValid;



function asn1SccExecutionStartErrorType_Equal (val1, val2 :  asn1SccExecutionStartErrorType) return Boolean
is

begin
	return val1 = val2;

end asn1SccExecutionStartErrorType_Equal;

function asn1SccExecutionStartErrorType_Init return asn1SccExecutionStartErrorType
is
    val: asn1SccExecutionStartErrorType;
begin
    val := asn1SccunknownExecutionStartError;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccExecutionStartErrorType_Init;

function asn1SccExecutionStartErrorType_IsConstraintValid(val : asn1SccExecutionStartErrorType) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((((((((((((((val = asn1SccunknownExecutionStartError)) OR ((val = asn1ScceventActionDefinitionIDExistsError)))) OR ((val = asn1ScceventActionDeleteEnabledDefinitionError)))) OR ((val = asn1ScceventActionUnknownEventDefinitionError)))) OR ((val = asn1ScceventActionUnknownEventActionDefinitionIDError)))) OR ((val = asn1SccsubServiceExecutionStartError)))) OR ((val = asn1SccinstructionExecutionStartError)))) OR ((val = asn1SccsetNonExistingParameter)))) OR ((val = asn1SccgetNonExistingParameter)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_EXECUTIONSTARTERRORTYPE);
    return ret;
end asn1SccExecutionStartErrorType_IsConstraintValid;



function asn1SccExecutionProgressErrorType_Equal (val1, val2 :  asn1SccExecutionProgressErrorType) return Boolean
is

begin
	return val1 = val2;

end asn1SccExecutionProgressErrorType_Equal;

function asn1SccExecutionProgressErrorType_Init return asn1SccExecutionProgressErrorType
is
    val: asn1SccExecutionProgressErrorType;
begin
    val := asn1SccunknownExecutionProgressError;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccExecutionProgressErrorType_Init;

function asn1SccExecutionProgressErrorType_IsConstraintValid(val : asn1SccExecutionProgressErrorType) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val = asn1SccunknownExecutionProgressError);
    ret.ErrorCode := (if ret.Success then 0 else ERR_EXECUTIONPROGRESSERRORTYPE);
    return ret;
end asn1SccExecutionProgressErrorType_IsConstraintValid;



function asn1SccExecutionCompletionErrorType_Equal (val1, val2 :  asn1SccExecutionCompletionErrorType) return Boolean
is

begin
	return val1 = val2;

end asn1SccExecutionCompletionErrorType_Equal;

function asn1SccExecutionCompletionErrorType_Init return asn1SccExecutionCompletionErrorType
is
    val: asn1SccExecutionCompletionErrorType;
begin
    val := asn1SccunknownExecutionCompletionError;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccExecutionCompletionErrorType_Init;

function asn1SccExecutionCompletionErrorType_IsConstraintValid(val : asn1SccExecutionCompletionErrorType) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((val = asn1SccunknownExecutionCompletionError)) OR ((val = asn1SccchecksumFailed)))) OR ((val = asn1SccaddressOutOfRange)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_EXECUTIONCOMPLETIONERRORTYPE);
    return ret;
end asn1SccExecutionCompletionErrorType_IsConstraintValid;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end THESIS_DATAVIEW;