/* File generated by kazoo for TASTE - do not edit */
#include "msp430fr5969_partition_interface.h"
#include <msp430.h>
#include <string.h>
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "transport.h"


#include "st05eventreport_vm_if.h"


void pro_ST05EventReport_EventActionTC05
      (const char *IN_buf_message, size_t size_IN_buf_message)

{
    extern SemaphoreHandle_t st05eventreport_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st05eventreport_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st05eventreport_EventActionTC05
      (IN_buf_message, size_IN_buf_message);


    xSemaphoreGive(st05eventreport_Semaphore);
}
void pro_ST05EventReport_TC05
      (const char *IN_buf_message, size_t size_IN_buf_message)

{
    extern SemaphoreHandle_t st05eventreport_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st05eventreport_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st05eventreport_TC05
      (IN_buf_message, size_IN_buf_message);


    xSemaphoreGive(st05eventreport_Semaphore);
}
#include "st08functionmanagement_vm_if.h"


void pro_ST08FunctionManagement_EventActionTC08
      (const char *IN_buf_message, size_t size_IN_buf_message)

{
    extern SemaphoreHandle_t st08functionmanagement_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st08functionmanagement_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st08functionmanagement_EventActionTC08
      (IN_buf_message, size_IN_buf_message);


    xSemaphoreGive(st08functionmanagement_Semaphore);
}
void pro_ST08FunctionManagement_TC08
      (const char *IN_buf_message, size_t size_IN_buf_message)

{
    extern SemaphoreHandle_t st08functionmanagement_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st08functionmanagement_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st08functionmanagement_TC08
      (IN_buf_message, size_IN_buf_message);


    xSemaphoreGive(st08functionmanagement_Semaphore);
}
#include "st11timebasedscheduling_vm_if.h"


void pro_ST11TimeBasedScheduling_EventActionTC11
      (const char *IN_buf_message, size_t size_IN_buf_message)

{
    extern SemaphoreHandle_t st11timebasedscheduling_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st11timebasedscheduling_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st11timebasedscheduling_EventActionTC11
      (IN_buf_message, size_IN_buf_message);


    xSemaphoreGive(st11timebasedscheduling_Semaphore);
}
void pro_ST11TimeBasedScheduling_TC11
      (const char *IN_buf_message, size_t size_IN_buf_message)

{
    extern SemaphoreHandle_t st11timebasedscheduling_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st11timebasedscheduling_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st11timebasedscheduling_TC11
      (IN_buf_message, size_IN_buf_message);


    xSemaphoreGive(st11timebasedscheduling_Semaphore);
}
// Required interfaces of function ST19EventAction

// Required interface EventActionTC05 in function ST19EventAction
void vm_st19eventaction_eventactiontc05
        (const char *IN_buf_message, size_t size_IN_buf_message)

{
    struct Request request;
    if(size_IN_buf_message != 0)
    {
        request.m_length = size_IN_buf_message;
        memcpy(request.m_data, IN_buf_message, size_IN_buf_message);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_ST05EventReport_EventActionTC05(&request);
}
// Required interface EventActionTC08 in function ST19EventAction
void vm_st19eventaction_eventactiontc08
        (const char *IN_buf_message, size_t size_IN_buf_message)

{
    struct Request request;
    if(size_IN_buf_message != 0)
    {
        request.m_length = size_IN_buf_message;
        memcpy(request.m_data, IN_buf_message, size_IN_buf_message);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_ST08FunctionManagement_EventActionTC08(&request);
}
// Required interface EventActionTC11 in function ST19EventAction
void vm_st19eventaction_eventactiontc11
        (const char *IN_buf_message, size_t size_IN_buf_message)

{
    struct Request request;
    if(size_IN_buf_message != 0)
    {
        request.m_length = size_IN_buf_message;
        memcpy(request.m_data, IN_buf_message, size_IN_buf_message);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_ST11TimeBasedScheduling_EventActionTC11(&request);
}
// Required interface EventActionTC20 in function ST19EventAction
void vm_st19eventaction_eventactiontc20
        (const char *IN_buf_message, size_t size_IN_buf_message)

{
    struct Request request;
    if(size_IN_buf_message != 0)
    {
        request.m_length = size_IN_buf_message;
        memcpy(request.m_data, IN_buf_message, size_IN_buf_message);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_ST20ParameterService_EventActionTC20(&request);
}
#include "st19eventaction_vm_if.h"


void pro_ST19EventAction_TC19
      (const char *IN_buf_message, size_t size_IN_buf_message)

{
    extern SemaphoreHandle_t st19eventaction_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st19eventaction_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st19eventaction_TC19
      (IN_buf_message, size_IN_buf_message);


    xSemaphoreGive(st19eventaction_Semaphore);
}
#include "st20parameterservice_vm_if.h"


void pro_ST20ParameterService_EventActionTC20
      (const char *IN_buf_message, size_t size_IN_buf_message)

{
    extern SemaphoreHandle_t st20parameterservice_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st20parameterservice_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st20parameterservice_EventActionTC20
      (IN_buf_message, size_IN_buf_message);


    xSemaphoreGive(st20parameterservice_Semaphore);
}
void pro_ST20ParameterService_TC20
      (const char *IN_buf_message, size_t size_IN_buf_message)

{
    extern SemaphoreHandle_t st20parameterservice_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st20parameterservice_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st20parameterservice_TC20
      (IN_buf_message, size_IN_buf_message);


    xSemaphoreGive(st20parameterservice_Semaphore);
}
// Required interfaces of function tc_handler

// Required interface TC05 in function tc_handler
void vm_tc_handler_tc05
        (const char *IN_buf_message, size_t size_IN_buf_message)

{
    struct Request request;
    if(size_IN_buf_message != 0)
    {
        request.m_length = size_IN_buf_message;
        memcpy(request.m_data, IN_buf_message, size_IN_buf_message);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_ST05EventReport_TC05(&request);
}
// Required interface TC08 in function tc_handler
void vm_tc_handler_tc08
        (const char *IN_buf_message, size_t size_IN_buf_message)

{
    struct Request request;
    if(size_IN_buf_message != 0)
    {
        request.m_length = size_IN_buf_message;
        memcpy(request.m_data, IN_buf_message, size_IN_buf_message);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_ST08FunctionManagement_TC08(&request);
}
// Required interface TC11 in function tc_handler
void vm_tc_handler_tc11
        (const char *IN_buf_message, size_t size_IN_buf_message)

{
    struct Request request;
    if(size_IN_buf_message != 0)
    {
        request.m_length = size_IN_buf_message;
        memcpy(request.m_data, IN_buf_message, size_IN_buf_message);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_ST11TimeBasedScheduling_TC11(&request);
}
// Required interface TC19 in function tc_handler
void vm_tc_handler_tc19
        (const char *IN_buf_message, size_t size_IN_buf_message)

{
    struct Request request;
    if(size_IN_buf_message != 0)
    {
        request.m_length = size_IN_buf_message;
        memcpy(request.m_data, IN_buf_message, size_IN_buf_message);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_ST19EventAction_TC19(&request);
}
// Required interface TC20 in function tc_handler
void vm_tc_handler_tc20
        (const char *IN_buf_message, size_t size_IN_buf_message)

{
    struct Request request;
    if(size_IN_buf_message != 0)
    {
        request.m_length = size_IN_buf_message;
        memcpy(request.m_data, IN_buf_message, size_IN_buf_message);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_ST20ParameterService_TC20(&request);
}
#include "tc_handler_vm_if.h"


void pro_tc_handler_tc(void)
{
    extern SemaphoreHandle_t tc_handler_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(tc_handler_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    tc_handler_tc();

    xSemaphoreGive(tc_handler_Semaphore);
}


#include "st05eventreport_vm_if.h"

void call_st05eventreport_eventactiontc05 (const char* buf, size_t len)
{
    extern SemaphoreHandle_t st05eventreport_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st05eventreport_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st05eventreport_EventActionTC05 (buf, len);
	xSemaphoreGive(st05eventreport_Semaphore);
}
#include "st05eventreport_vm_if.h"

void call_st05eventreport_tc05 (const char* buf, size_t len)
{
    extern SemaphoreHandle_t st05eventreport_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st05eventreport_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st05eventreport_TC05 (buf, len);
	xSemaphoreGive(st05eventreport_Semaphore);
}
#include "st08functionmanagement_vm_if.h"

void call_st08functionmanagement_eventactiontc08 (const char* buf, size_t len)
{
    extern SemaphoreHandle_t st08functionmanagement_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st08functionmanagement_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st08functionmanagement_EventActionTC08 (buf, len);
	xSemaphoreGive(st08functionmanagement_Semaphore);
}
#include "st08functionmanagement_vm_if.h"

void call_st08functionmanagement_tc08 (const char* buf, size_t len)
{
    extern SemaphoreHandle_t st08functionmanagement_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st08functionmanagement_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st08functionmanagement_TC08 (buf, len);
	xSemaphoreGive(st08functionmanagement_Semaphore);
}
#include "st11timebasedscheduling_vm_if.h"

void call_st11timebasedscheduling_eventactiontc11 (const char* buf, size_t len)
{
    extern SemaphoreHandle_t st11timebasedscheduling_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st11timebasedscheduling_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st11timebasedscheduling_EventActionTC11 (buf, len);
	xSemaphoreGive(st11timebasedscheduling_Semaphore);
}
#include "st11timebasedscheduling_vm_if.h"

void call_st11timebasedscheduling_tc11 (const char* buf, size_t len)
{
    extern SemaphoreHandle_t st11timebasedscheduling_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st11timebasedscheduling_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st11timebasedscheduling_TC11 (buf, len);
	xSemaphoreGive(st11timebasedscheduling_Semaphore);
}
#include "st19eventaction_vm_if.h"

void call_st19eventaction_tc19 (const char* buf, size_t len)
{
    st19eventaction_TC19 (buf, len);
}
#include "st20parameterservice_vm_if.h"

void call_st20parameterservice_eventactiontc20 (const char* buf, size_t len)
{
    extern SemaphoreHandle_t st20parameterservice_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st20parameterservice_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st20parameterservice_EventActionTC20 (buf, len);
	xSemaphoreGive(st20parameterservice_Semaphore);
}
#include "st20parameterservice_vm_if.h"

void call_st20parameterservice_tc20 (const char* buf, size_t len)
{
    extern SemaphoreHandle_t st20parameterservice_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(st20parameterservice_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    st20parameterservice_TC20 (buf, len);
	xSemaphoreGive(st20parameterservice_Semaphore);
}
#include "tc_handler_vm_if.h"

void call_tc_handler_tc (const char* buf, size_t len)
{
    tc_handler_tc();
}
